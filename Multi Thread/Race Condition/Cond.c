/* 说明：1.条件变量可以理解为信号
*       2.当某个条件(自定义)产生后，内核会自动通知条件变量注册列表中的所有线程(或者随即某个线程)
*       3.条件变量API中互斥量参数的作用：保护条件变量(可以理解条件变量为公共资源)
*       4.传递给API的互斥量必须是被锁住的
*  举个例子：1）有两个线程A和B，如果A执行到某一步，再想往下执行需要满足全局变量VA=1，比如while(VA!=1);这样，那么这就造成了轮询，有因为VA是全局的，肯定
            还有竞争，那么全部代码应该是
                                      while(1){
                                      pthread_mutex_lock(&mutex_VA); 
                                      if(VA==1) {dosomething();break;}
                                      else donothing();
*                                     pthread_mutex_unlock(&mutex_VA);
                                      }
            这样还是比较低效的，首先需要判断资源是不是可用，其次需要看资源的值是否满足，如果满足还好，如果不满足就要进while(1)循环，如果资源一直可读，
            那么就是忙等状态。此时，只有B线程对mutex_VA加锁，然后让VA==1,下次轮询时，A线程才会进入dosomething。
            2）那么如果我们使用条件变量，只需要通过调用pthread_cond_wait把本线程挂到条件变量的轮询列表中，阻塞等待即可。但是！！！需要B线程在
*/
