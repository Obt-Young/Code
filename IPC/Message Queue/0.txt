#1 - 消息队列是一个链表结构
#2 - msgsnd每次把消息放到链表的尾部
#3 - msgrcv如果不指定消息类型(消息编号),那么默认是从链表头取一条消息的(先进先出)，如果指定消息类型，则不受限制，可以从链表的任意位置取消息
     (ps:这里的“取”，是指从队列里面摘除，msgrcv成功后，相应的消息将会被移除链表。所以"取“指定消息类型的消息时,在确保消息是想要
	的消息时，把消息拿出来。那么是否存在把消息重新塞回链表中呢？？？)
#4 - 消息队列可容纳的最大字节数可通过ulimit -q查询
     消息队列可容纳最大消息数，可由 最大字节数/单个消息最大字节数 计算得到，这个值是动态的，和RAM大小相关
     可通过查询消息队列的结构体来获取最大限制的参数，结构体为struc msqid_ds,每个消息队列都有这样一个管理结构，这个管理结构还有很多其他参数可
     供查询
#5 - msgsnd的第三个参数为flag，如果flag包含IPC_NOWAIT,那么当队列被塞满的时候(消息数达到最大限制/总字节数达到最大限制)，msgsnd会返回-1，errno
     为EAGAIN。
     如果没设置IPC_NOWAIT,那么msgsnd将会阻塞。msgsnd的阻塞会在如下三个情况下返回，并向下继续执行：
         1）队列中有空间可以接纳新的消息，msgsnd正常返回
         2）队列被从系统中移除了，msgsnd返回-1，errno=EIDRM(标示符被删除)
         3）发生了一个中断，中断函数处理完，msgsnd返回-1，errno=EINTR(被中断打断)

#6 - msg系列函数在做完自己负责的动作后，都会更新一下管理结构  struct msqid_ds
#7 - msgrcv会指定缓冲区，如果缓冲区不够长，那么"要么读出来的消息被截短，多出的部分被抛弃(msgrcv的时候指定flag包含MSG_NOERROR)",”要么直接返回-1
     同时errno=E2BIG(没指定MSG_NOERROR)“

#8 - msgrcv和msgsnd一样，具备阻塞性质，如果队列空了，指定IPC_NOWAIT时，返回-1，errno=ENOMSG ； 如果没指定IPC_NOWAIT，那么一直阻塞读队列。
     阻塞态的中断同样有三种情况(和msgsnd一样)：
	 1）有新消息可读
         2）队列被移除
         3）发生中断了

